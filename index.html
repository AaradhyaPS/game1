<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Endless Level Devil — Robot Player (Erika-ish Chibi)</title>
<style>
  html,body{height:100%;margin:0;background:#061022;font-family:Inter,Arial,Helvetica,sans-serif}
  #canvasWrap{display:flex;align-items:center;justify-content:center;height:100vh}
  canvas{border-radius:10px;box-shadow:0 14px 40px rgba(0,0,0,0.6);max-width:100%;height:auto;background:#87CEEB}
  #uiTop{position:fixed;left:12px;top:12px;z-index:30;color:#fff}
  .box{background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;margin-bottom:8px}
  #controls{position:fixed;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;z-index:30}
  .btn{background:#2b8cff;border:0;padding:10px 14px;border-radius:10px;color:#fff;font-weight:700;box-shadow:0 6px 12px rgba(0,0,0,0.25);touch-action:none}
  #menu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;color:#fff}
  .panel{background:linear-gradient(180deg,rgba(0,0,0,0.75),rgba(0,0,0,0.45));padding:18px;border-radius:14px;text-align:center;width:360px}
  @media (max-width:600px){ .panel{width:92vw} canvas{width:95vw} }
</style>
</head>
<body>
<div id="canvasWrap">
  <canvas id="game" width="1000" height="560"></canvas>
</div>

<div id="uiTop">
  <div class="box">Level: <span id="level">1</span> &nbsp; Score: <span id="score">0</span></div>
  <div class="box">Best: <span id="best">0</span></div>
</div>

<div id="controls">
  <button id="acc" class="btn">▶</button>
  <button id="jump" class="btn">▲</button>
  <button id="pause" class="btn">Pause</button>
</div>

<div id="menu">
  <div class="panel" id="startPanel">
    <h2 style="margin:6px 0 0 0">Endless Level Devil</h2>
    <p style="opacity:0.9">Endless, procedural levels — reach the finish to advance. Robot player: chibi round-head (Erika-ish).</p>
    <button id="startBtn" class="btn">Start Game</button>
    <button id="how" class="btn" style="background:#4caf50;margin-top:8px">How to Play</button>
    <div style="height:8px"></div>
    <div style="font-size:12px;opacity:0.8">Controls: A/D or ←/→, W/Space to jump. On mobile use buttons.</div>
  </div>

  <div class="panel" id="pausePanel" style="display:none">
    <h3>Paused</h3>
    <button id="resume" class="btn">Resume</button>
    <button id="restart" class="btn" style="background:#e74c3c;margin-top:10px">Restart</button>
  </div>

  <div class="panel" id="howPanel" style="display:none">
    <h3>How to Play</h3>
    <p>Reach the end of each level segment to advance. Avoid spikes, fake floors, pop-up spikes and moving platforms. Difficulty increases gradually.</p>
    <button id="backToMenu" class="btn">Back</button>
  </div>
</div>

<script>
/* ---------- Basic helpers ---------- */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r=6){
    this.beginPath();
    this.moveTo(x+r,y);
    this.lineTo(x+w-r,y);
    this.quadraticCurveTo(x+w,y,x+w,y+r);
    this.lineTo(x+w,y+h-r);
    this.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    this.lineTo(x+r,y+h);
    this.quadraticCurveTo(x,y+h,x,y+h-r);
    this.lineTo(x,y+r);
    this.quadraticCurveTo(x,y,x+r,y);
    this.closePath();
  };
}

/* ---------- Config ---------- */
const CANVAS_W = 1000, CANVAS_H = 560;
const CAMERA_LEFT_PADDING = 260;
const SEGMENT_W = 700;
const START_SEGMENTS = 5;
let SOUND_ON = true;

/* ---------- Canvas & UI ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CANVAS_W; canvas.height = CANVAS_H;

const levelEl = document.getElementById('level');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');

const startBtn = document.getElementById('startBtn'), howBtn = document.getElementById('how');
const backToMenu = document.getElementById('backToMenu'), startPanel = document.getElementById('startPanel');
const pausePanel = document.getElementById('pausePanel'), howPanel = document.getElementById('howPanel');

const accBtn = document.getElementById('acc'), jumpBtn = document.getElementById('jump');
const pauseBtn = document.getElementById('pause'), resumeBtn = document.getElementById('resume'), restartBtn = document.getElementById('restart');

let HIGH_SCORE = parseInt(localStorage.getItem('lv_high') || '0');
bestEl.innerText = HIGH_SCORE;

/* ---------- Input ---------- */
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key==='p') togglePause(); if(e.key==='m') SOUND_ON=!SOUND_ON; });
window.addEventListener('keyup', e=>{ keys[e.key]=false; });

accBtn.addEventListener('pointerdown', ()=> keys['ArrowRight']=true);
accBtn.addEventListener('pointerup', ()=> keys['ArrowRight']=false);
jumpBtn.addEventListener('pointerdown', ()=>{ keys[' '] = true; setTimeout(()=> keys[' '] = false, 120); });

pauseBtn.addEventListener('click', togglePause);
resumeBtn.addEventListener('click', resumeGame);
restartBtn.addEventListener('click', ()=> resetAll(true));

startBtn.addEventListener('click', ()=> { startPanel.style.display='none'; begin(); });
howBtn.addEventListener('click', ()=> { startPanel.style.display='none'; howPanel.style.display='block'; });
backToMenu.addEventListener('click', ()=> { howPanel.style.display='none'; startPanel.style.display='block'; });

/* ---------- Audio (tiny WebAudio) ---------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
function sfx(freq=440,type='sine',dur=0.08,vol=0.07){ if(!SOUND_ON) return; ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+dur); setTimeout(()=> o.stop(), dur*1000+20); }
function sJump(){ sfx(520,'triangle',0.12,0.12); } function sLand(){ sfx(260,'square',0.06,0.06); } function sDie(){ sfx(120,'sine',0.28,0.18); }

/* ---------- Particle system (subtle metallic sparks) ---------- */
let particles = [];
function spawnSparks(worldX, worldY, amount=4){
  for(let i=0;i<amount;i++){
    particles.push({
      x: worldX + (Math.random()*24 - 12),
      y: worldY + (Math.random()*6 - 4),
      vx: (Math.random()*2 - 1),
      vy: -Math.random()*1.6,
      life: 1,
      size: 2 + Math.random()*3,
      color: `rgba(${160+Math.random()*60},${200+Math.random()*40},255,1)`
    });
  }
}
function updateParticles(dt){
  for(let p of particles){
    p.x += p.vx * (dt/16);
    p.y += p.vy * (dt/16);
    p.vy += 0.06 * (dt/16);
    p.life -= 0.01 * (dt/16);
  }
  particles = particles.filter(p => p.life > 0);
}
function drawParticles(){
  for(let p of particles){
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x - camX, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* ---------- Entities ---------- */
class Player {
  constructor(){ this.reset(); this.anim=0; this.facing=1; }
  reset(){ this.x = 120; this.y = 360; this.w = 32; this.h = 48; this.vx = 0; this.vy = 0; this.onGround = false; }
  collision(o){ return this.x+this.w>o.x && this.x < o.x+o.w && this.y+this.h>o.y && this.y < o.y+o.h; }
  die(){ if(SOUND_ON) sDie(); score = Math.max(0, score-80); this.reset(); camX = Math.max(0, this.x - CAMERA_LEFT_PADDING); }
  update(dt){
    const accel = 0.25 * (dt/16);
    if(keys['a']||keys['ArrowLeft']){ this.vx -= accel; this.facing=-1; }
    if(keys['d']||keys['ArrowRight']){ this.vx += accel; this.facing=1; }
    this.vx = Math.max(-4.2, Math.min(this.vx, 6.2));
    this.vx *= 0.993;
    this.vy += 0.9 * (dt/16);
    if((keys['w']||keys[' ']||keys['ArrowUp']) && this.onGround){
      this.vy = -15.2; this.onGround = false; if(SOUND_ON) sJump(); spawnSparks(this.x+this.w/2, this.y+this.h, 5);
    }
    this.x += this.vx * (dt/16);
    this.y += this.vy * (dt/16);

    // platform collisions
    this.onGround = false;
    for(let p of level.platforms){
      if(this.x + this.w > p.x && this.x < p.x + p.w){
        if(this.y + this.h > p.y && this.y + this.h < p.y + 22 && this.vy >= 0){
          this.y = p.y - this.h;
          this.vy = 0;
          this.onGround = true;
          if(p.type === 'moving' && p.vx) this.x += p.vx * (dt/16);
          if(SOUND_ON) sLand(); spawnSparks(this.x+this.w/2, this.y+this.h, 6);
        }
      }
    }

    // traps
    for(let s of level.spikes) if(this.collision(s)) this.die();
    for(let ps of level.popSpikes) if(ps.active && this.collision(ps)) this.die();
    for(let f of level.fakeFloors) if(f.broken && this.collision({x:f.x,y:f.y,w:f.w,h:32})) this.die();

    if(this.y > canvas.height + 200) this.die();

    this.anim += Math.abs(this.vx) * 0.05;
  }

  // draw chibi round-headed robot (mix A + C)
  draw(){
    const px = this.x - camX, py = this.y;
    ctx.save();
    ctx.translate(px + this.w/2, py + this.h/2);
    if(this.facing < 0) ctx.scale(-1,1);

    const bob = Math.sin(this.anim * 0.28) * 2;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath(); ctx.ellipse(0, this.h/2 + 10, 24, 9, 0,0,Math.PI*2); ctx.fill();

    // body (small chibi body)
    ctx.fillStyle = '#4b5563';
    ctx.roundRect(-12, -2 + bob, 24, 30, 6);
    ctx.fill();

    // limbs - simple rectangles
    ctx.fillStyle = '#374151';
    ctx.fillRect(-14, 28 + bob, 10, 22);
    ctx.fillRect(4, 28 + bob, 10, 22);

    // feet
    ctx.fillStyle = '#111827';
    ctx.fillRect(-16, 46 + bob, 12, 6);
    ctx.fillRect(2, 46 + bob, 12, 6);

    // neck connector
    ctx.fillStyle = '#2d3748';
    ctx.fillRect(-6, -10 + bob, 12, 6);

    // head (round) - larger than body (chibi)
    ctx.fillStyle = '#dfe6ee';
    ctx.beginPath();
    ctx.arc(0, -18 + bob, 30, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#9aa6b3'; ctx.lineWidth = 2; ctx.stroke();

    // face panel (metallic rectangle)
    ctx.fillStyle = '#f8fafc';
    ctx.roundRect(-14, -32 + bob, 28, 20, 6);
    ctx.fill();

    // LED eyes (glowing) - two squares
    const eyeGlow = (Math.abs(Math.sin(Date.now()*0.01)) * 0.6) + 0.6;
    ctx.fillStyle = `rgba(60,170,255,${eyeGlow})`;
    ctx.fillRect(-10, -28 + bob, 8, 10);
    ctx.fillRect(2, -28 + bob, 8, 10);
    // eye rims
    ctx.strokeStyle = '#0b3b56'; ctx.lineWidth = 1; ctx.strokeRect(-10, -28 + bob, 8, 10); ctx.strokeRect(2, -28 + bob, 8, 10);

    // small antenna
    ctx.beginPath();
    ctx.moveTo(10, -44 + bob); ctx.lineTo(18, -52 + bob);
    ctx.strokeStyle = '#374151'; ctx.lineWidth = 3; ctx.stroke();
    ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(18, -52 + bob, 3.5, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }
}

/* ---------- Other objects (platforms, spikes, pop spikes, fake floors) ---------- */
class Platform {
  constructor(x,y,w,type='static',vx=0,range=0){ this.x=x; this.y=y; this.w=w; this.h=20; this.type=type; this.vx=vx; this.range=range; this.origX=x; }
  update(dt){ if(this.type==='moving'){ this.x += this.vx * (dt/16); if(this.x < this.origX-this.range || this.x > this.origX+this.range) this.vx *= -1; } }
  draw(){ ctx.fillStyle = this.type === 'moving' ? '#2b6cb4' : '#6b7280'; ctx.fillRect(this.x - camX, this.y, this.w, this.h); ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.strokeRect(this.x - camX, this.y, this.w, this.h); }
}
class Spike { constructor(x,y,w=28){ this.x=x; this.y=y; this.w=w; this.h=w; } draw(){ ctx.fillStyle='#b91c1c'; ctx.beginPath(); ctx.moveTo(this.x - camX, this.y + this.h); ctx.lineTo(this.x - camX + this.w/2, this.y); ctx.lineTo(this.x - camX + this.w, this.y + this.h); ctx.fill(); ctx.strokeStyle='#7b0000'; ctx.stroke(); } }
class PopSpike { constructor(x,y){ this.x=x; this.baseY=y+40; this.y=this.baseY; this.w=28; this.h=28; this.triggerAt=x-140; this.active=false; this.timer=0; } activate(){ this.active=true; this.timer=18; } update(dt){ if(this.active && this.timer>0){ this.y -= 6; this.timer--; } else if(this.active && this.timer===0){ if(this.y <= this.baseY - 40) this.timer = -36; } else if(this.active && this.timer < 0){ this.y += 6; this.timer++; if(this.y >= this.baseY){ this.y = this.baseY; this.active=false; this.timer=0; } } } draw(){ ctx.fillStyle='#b91c1c'; ctx.beginPath(); ctx.moveTo(this.x - camX, this.y + this.h); ctx.lineTo(this.x - camX + this.w/2, this.y); ctx.lineTo(this.x - camX + this.w, this.y + this.h); ctx.fill(); ctx.strokeStyle='#7b0000'; ctx.stroke(); } }
class FakeFloor { constructor(x,y,w,delay=18){ this.x=x; this.y=y; this.w=w; this.h=16; this.delay=delay; this.stepStarted=false; this.timer=0; this.broken=false; } draw(){ ctx.fillStyle = this.broken ? '#6c3' : '#b78b5a'; ctx.fillRect(this.x - camX, this.y, this.w, this.h); } }

/* ---------- Level generation (procedural, progressive) ---------- */
let level = { platforms:[], spikes:[], popSpikes:[], fakeFloors:[], mapWidth: SEGMENT_W * START_SEGMENTS, finishX:0 };

function rand(min,max){ return Math.random()*(max-min)+min; }
function rint(a,b){ return Math.floor(rand(a,b+1)); }

function buildLevelFor(number){
  level.platforms=[]; level.spikes=[]; level.popSpikes=[]; level.fakeFloors=[];
  const difficulty = Math.min(1, 0.12 + (number-1)*0.06);
  const segments = START_SEGMENTS + Math.floor(number*0.6);
  level.mapWidth = segments * SEGMENT_W;

  // base ground
  level.platforms.push(new Platform(0,420, level.mapWidth + 400));

  // generate platforms across segments
  let x = 220;
  while(x < level.mapWidth - 240){
    const gap = rint(100 + Math.floor(difficulty*120), 220 + Math.floor(difficulty*160));
    const pW = rint(120, 380);
    const pY = rint(260, 400 - Math.floor(difficulty*60));
    const px = x + gap;
    level.platforms.push(new Platform(px, pY, pW));
    // moving platform chance
    if(Math.random() < 0.12 + difficulty*0.25){
      const mv = new Platform(px + rint(20,80), pY - 40, rint(80,140), 'moving', (Math.random()<0.5?1:-1)*(1.2 + difficulty*1.6), rint(40, 140));
      level.platforms.push(mv);
    }
    // spikes
    if(Math.random() < 0.3 + difficulty*0.5){
      const sx = px + rint(10, Math.max(20, pW-30));
      level.spikes.push(new Spike(sx, pY - 28));
    }
    // pop spikes
    if(Math.random() < 0.18 + difficulty*0.45){
      const psx = px + rint(-40, Math.max(40, pW+40));
      level.popSpikes.push(new PopSpike(psx, pY));
    }
    // fake floors
    if(Math.random() < 0.16 + difficulty*0.35){
      const fx = px + rint(40, Math.max(40, pW-40));
      level.fakeFloors.push(new FakeFloor(fx, pY - 16, rint(60,140)));
    }
    x += gap + pW + rint(80,200);
    if(x > level.mapWidth - 240) break;
  }
  level.finishX = level.mapWidth - 160;
}

/* ---------- State ---------- */
let player = new Player();
let camX = 0;
let levelNumber = 1;
let score = 0;
let paused=false;
let menuVisible=true;

/* ---------- Controls ---------- */
function begin(){ menuVisible=false; startPanel.style.display='none'; howPanel.style.display='none'; pausePanel.style.display='none'; buildLevelFor(levelNumber); player.reset(); camX=0; score=0; lastTime = performance.now(); requestAnimationFrame(loop); }
function resetAll(full=false){ levelNumber=1; score=0; player.reset(); buildLevelFor(levelNumber); camX=0; levelEl.innerText=levelNumber; scoreEl.innerText=score; localStorage.setItem('lv_high', HIGH_SCORE); menuVisible=false; startPanel.style.display='none'; pausePanel.style.display='none'; }
function togglePause(){ paused = !paused; if(paused){ pausePanel.style.display='block'; } else { pausePanel.style.display='none'; lastTime = performance.now(); requestAnimationFrame(loop); } }
function resumeGame(){ paused=false; pausePanel.style.display='none'; lastTime = performance.now(); requestAnimationFrame(loop); }

/* ---------- Advance level ---------- */
function advanceLevel(){
  levelNumber++;
  levelEl.innerText = levelNumber;
  score += Math.floor(level.mapWidth/10);
  scoreEl.innerText = score;
  if(score > HIGH_SCORE){ HIGH_SCORE = score; localStorage.setItem('lv_high', HIGH_SCORE); bestEl.innerText = HIGH_SCORE; }
  buildLevelFor(levelNumber);
  player.reset(); camX = 0;
}

/* ---------- Game loop ---------- */
let lastTime = performance.now();
function loop(now){
  if(paused || menuVisible){ lastTime = performance.now(); return; }
  const dt = Math.min(40, now - lastTime); lastTime = now;

  // update platforms
  for(let p of level.platforms) if(p.type === 'moving') p.update(dt);
  // update pop spikes
  for(let ps of level.popSpikes){ if(!ps.active && player.x > ps.triggerAt) ps.activate(); if(ps.active) ps.update(dt); }
  // fake floors
  for(let f of level.fakeFloors){
    if(!f.broken && player.x + player.w > f.x && player.x < f.x + f.w && player.y + player.h > f.y && player.y < f.y + f.h){
      if(!f.stepStarted){ f.stepStarted = true; f.timer = f.delay; }
    }
    if(f.stepStarted && f.timer > 0) f.timer--;
    if(f.stepStarted && f.timer === 0 && !f.broken) f.broken = true;
    if(f.broken) f.y += 6 * (dt/16);
  }

  player.update(dt);
  updateParticles(dt);

  camX = player.x - CAMERA_LEFT_PADDING; if(camX < 0) camX = 0;

  score = Math.max(score, Math.floor(player.x + (levelNumber-1)*500));
  scoreEl.innerText = score;

  if(player.x > level.mapWidth - 120){ player.victoryTimer = 30; advanceLevel(); }

  drawScene();
  requestAnimationFrame(loop);
}

/* ---------- Drawing ---------- */
function drawScene(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background simple
  const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#87CEEB'); g.addColorStop(1,'#cfe9ff'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // ground
  ctx.fillStyle = '#6b8e23';
  ctx.fillRect(-camX, 460, canvas.width + camX, canvas.height - 460);

  // platforms
  for(let p of level.platforms) p.draw();
  // fake floors
  for(let f of level.fakeFloors) f.draw();
  // spikes
  for(let s of level.spikes) s.draw();
  // pop spikes
  for(let ps of level.popSpikes) ps.draw();

  // finish marker
  ctx.fillStyle = '#ffd54f'; ctx.fillRect(level.finishX - camX, 300, 12, 140);
  ctx.fillStyle = '#6d4c41'; ctx.fillRect(level.finishX - camX - 8, 420, 36, 20);

  drawParticles();
  player.draw();

  // hint
  ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(canvas.width - 220, 8, 210, 36);
  ctx.fillStyle = '#fff'; ctx.font = '14px Inter, Arial'; ctx.fillText('Finish →', canvas.width - 180, 30);
}

/* ---------- Init ---------- */
buildLevelFor(levelNumber);
levelEl.innerText = levelNumber;
scoreEl.innerText = score;

/* show start menu */
startPanel.style.display = 'block';
pausePanel.style.display = 'none';
howPanel.style.display = 'none';
menuVisible = true;

</script>
</body>
</html>
