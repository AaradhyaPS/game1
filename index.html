<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Endless Silhouette Runner — Upload-ready</title>
<style>
  html,body{height:100%;margin:0;background:#071220;font-family:Inter,Arial,Helvetica,sans-serif}
  #canvasWrap{display:flex;align-items:center;justify-content:center;height:100vh}
  canvas{border-radius:10px;box-shadow:0 14px 40px rgba(0,0,0,0.6);max-width:100%;height:auto;background:linear-gradient(#87CEEB,#cfe9ff)}
  #uiTop{position:fixed;left:12px;top:12px;z-index:30;color:#fff}
  .box{background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;margin-bottom:8px}
  #controls{position:fixed;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;z-index:30}
  .btn{background:#1f2937;border:0;padding:10px 14px;border-radius:10px;color:#fff;font-weight:700;box-shadow:0 6px 12px rgba(0,0,0,0.25);touch-action:none}
  #menu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;color:#fff}
  .panel{background:linear-gradient(180deg,rgba(0,0,0,0.75),rgba(0,0,0,0.45));padding:18px;border-radius:14px;text-align:center;width:360px}
  .small{font-size:12px;color:#ddd}
  @media (max-width:600px){ .panel{width:92vw} canvas{width:95vw} }
</style>
</head>
<body>
<div id="canvasWrap"><canvas id="game" width="1000" height="560"></canvas></div>

<div id="uiTop">
  <div class="box">Level: <span id="level">1</span> &nbsp; Score: <span id="score">0</span> &nbsp; Coins: <span id="coins">0</span></div>
  <div class="box">Best: <span id="best">0</span></div>
</div>

<div id="controls">
  <button id="acc" class="btn">▶</button>
  <button id="jump" class="btn">▲</button>
  <button id="pause" class="btn">Pause</button>
  <button id="mute" class="btn">Mute</button>
</div>

<div id="menu">
  <div class="panel" id="startPanel">
    <h2 style="margin:6px 0 0 0">Endless Silhouette Runner</h2>
    <p class="small" style="opacity:0.9">Endless, procedural platform levels. Solid black silhouette runner (4-frame smooth run).</p>
    <button id="startBtn" class="btn">Start Game</button>
    <button id="how" class="btn" style="background:#4caf50;margin-top:8px">How to Play</button>
    <div style="height:8px"></div>
    <div class="small">Controls: A/D or ←/→, W/Space to jump. Mobile: use buttons on the right.</div>
  </div>

  <div class="panel" id="pausePanel" style="display:none">
    <h3>Paused</h3>
    <button id="resume" class="btn">Resume</button>
    <button id="restart" class="btn" style="background:#e74c3c;margin-top:10px">Restart</button>
  </div>

  <div class="panel" id="howPanel" style="display:none">
    <h3>How to Play</h3>
    <p class="small">Avoid traps. Collect coins for points. Reach the finish to generate the next level. You respawn at the last checkpoint when you die.</p>
    <button id="backToMenu" class="btn">Back</button>
  </div>
</div>

<script>
/* ----------------- Helpers ----------------- */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r=6){
    this.beginPath();
    this.moveTo(x+r,y);
    this.lineTo(x+w-r,y);
    this.quadraticCurveTo(x+w,y,x+w,y+r);
    this.lineTo(x+w,y+h-r);
    this.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    this.lineTo(x+r,y+h);
    this.quadraticCurveTo(x,y+h,x,y+h-r);
    this.lineTo(x,y+r);
    this.quadraticCurveTo(x,y,x+r,y);
    this.closePath();
  };
}

/* ----------------- Config ----------------- */
const CANVAS_W = 1000, CANVAS_H = 560;
const CAMERA_LEFT_PADDING = 260;
const SEGMENT_W = 700;
const START_SEGMENTS = 5;
let SOUND_ON = true;

/* ----------------- Canvas & UI ----------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CANVAS_W; canvas.height = CANVAS_H;

const levelEl = document.getElementById('level');
const scoreEl = document.getElementById('score');
const coinsEl = document.getElementById('coins');
const bestEl = document.getElementById('best');

const startBtn = document.getElementById('startBtn'), howBtn = document.getElementById('how');
const backToMenu = document.getElementById('backToMenu'), startPanel = document.getElementById('startPanel');
const pausePanel = document.getElementById('pausePanel'), howPanel = document.getElementById('howPanel');

const accBtn = document.getElementById('acc'), jumpBtn = document.getElementById('jump');
const pauseBtn = document.getElementById('pause'), resumeBtn = document.getElementById('resume'), restartBtn = document.getElementById('restart');
const muteBtn = document.getElementById('mute');

let HIGH_SCORE = parseInt(localStorage.getItem('lv_high') || '0');
bestEl.innerText = HIGH_SCORE;

/* ----------------- Input ----------------- */
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key==='p') togglePause(); if(e.key==='m'){ SOUND_ON=!SOUND_ON; updateMute(); }});
window.addEventListener('keyup', e=>{ keys[e.key]=false; });

accBtn.addEventListener('pointerdown', ()=> keys['ArrowRight']=true);
accBtn.addEventListener('pointerup', ()=> keys['ArrowRight']=false);
jumpBtn.addEventListener('pointerdown', ()=>{ keys[' '] = true; setTimeout(()=> keys[' '] = false, 120); });

pauseBtn.addEventListener('click', togglePause);
resumeBtn.addEventListener('click', resumeGame);
restartBtn.addEventListener('click', ()=> resetAll(true));
startBtn.addEventListener('click', ()=> { startPanel.style.display='none'; begin(); });
howBtn.addEventListener('click', ()=> { startPanel.style.display='none'; howPanel.style.display='block'; });
backToMenu.addEventListener('click', ()=> { howPanel.style.display='none'; startPanel.style.display='block'; });
muteBtn.addEventListener('click', ()=> { SOUND_ON = !SOUND_ON; updateMute(); });
function updateMute(){ muteBtn.innerText = SOUND_ON ? 'Mute' : 'Unmute'; }

/* ----------------- Audio (small) ----------------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new AudioCtx(); }
function sfx(freq=440,type='sine',dur=0.08,vol=0.07){ if(!SOUND_ON) return; ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+dur); setTimeout(()=> o.stop(), dur*1000+20); }
function sJump(){ sfx(520,'triangle',0.12,0.12); } function sLand(){ sfx(260,'square',0.06,0.06); } function sDie(){ sfx(120,'sine',0.28,0.18); } function sCoin(){ sfx(780,'sine',0.08,0.08); } function sCheckpoint(){ sfx(440,'sawtooth',0.12,0.12); }

/* ----------------- Entities ----------------- */
/* Silhouette runner: 4-frame smooth run cycle */
class Player {
  constructor(){ this.reset(); this.anim = 0; this.frame = 0; this.facing = 1; this.checkpointX = 120; this.checkpointY = 360; }
  reset(){ this.x = this.checkpointX; this.y = this.checkpointY; this.w = 30; this.h = 46; this.vx = 0; this.vy = 0; this.onGround = false; this.runningTime = 0; }
  collision(o){ return this.x+this.w>o.x && this.x < o.x+o.w && this.y+this.h>o.y && this.y < o.y+o.h; }
  die(){ if(SOUND_ON) sDie(); score = Math.max(0, score - 80); this.reset(); camX = Math.max(0, this.x - CAMERA_LEFT_PADDING); }
  update(dt){
    const accel = 0.25 * (dt/16);
    if(keys['a']||keys['ArrowLeft']){ this.vx -= accel; this.facing = -1; }
    if(keys['d']||keys['ArrowRight']){ this.vx += accel; this.facing = 1; }
    this.vx = Math.max(-4.2, Math.min(this.vx, 6.2));
    this.vx *= 0.993;
    this.vy += 0.9 * (dt/16);
    if((keys['w']||keys[' ']||keys['ArrowUp']) && this.onGround){
      this.vy = -15.2; this.onGround = false; if(SOUND_ON) sJump();
    }
    this.x += this.vx * (dt/16);
    this.y += this.vy * (dt/16);

    // platform collisions
    this.onGround = false;
    for(let p of level.platforms){
      if(this.x + this.w > p.x && this.x < p.x + p.w){
        if(this.y + this.h > p.y && this.y + this.h < p.y + 22 && this.vy >= 0){
          this.y = p.y - this.h;
          this.vy = 0;
          this.onGround = true;
          if(p.type === 'moving' && p.vx) this.x += p.vx * (dt/16);
          if(SOUND_ON) sLand();
        }
      }
    }

    // traps
    for(let s of level.spikes) if(this.collision(s)) this.die();
    for(let ps of level.popSpikes) if(ps.active && this.collision(ps)) this.die();
    for(let f of level.fakeFloors) if(f.broken && this.collision({x:f.x,y:f.y,w:f.w,h:32})) this.die();

    // coins
    for(let c of level.coins){
      if(!c.collected && this.x + this.w > c.x && this.x < c.x + c.size && this.y + this.h > c.y && this.y < c.y + c.size){
        c.collected = true; coinsCollected++; score += 100; coinsEl.innerText = coinsCollected; if(SOUND_ON) sCoin();
      }
    }

    // checkpoints activation
    for(let cp of level.checkpoints){
      if(!cp.activated && this.x + this.w > cp.x){
        cp.activated = true;
        this.checkpointX = cp.x - 20; this.checkpointY = cp.y - this.h;
        if(SOUND_ON) sCheckpoint();
      }
    }

    if(this.y > canvas.height + 200) this.die();

    // animation: 4-frame smooth run based on runningTime
    if(this.onGround && Math.abs(this.vx) > 0.5){
      this.runningTime += Math.abs(this.vx) * (dt/16);
      // frame 0..3
      this.frame = Math.floor((this.runningTime * 10) % 4);
    } else {
      this.frame = 0; // default standing pose
    }
  }

  draw(){
    const px = this.x - camX, py = this.y;
    ctx.save();
    ctx.translate(px + this.w/2, py + this.h/2);
    if(this.facing < 0) ctx.scale(-1,1);

    // draw body silhouette (head, torso, arms, legs) but animate limbs by frame
    ctx.fillStyle = '#000';

    // simple parameters for frames (angles/offsets)
    const frames = [
      {legOffset: 6, armAngle: 18},    // frame 0
      {legOffset: 2, armAngle: 6},     // frame 1
      {legOffset: -6, armAngle: -10},  // frame 2
      {legOffset: -2, armAngle: -2}    // frame 3
    ];
    const f = frames[this.frame];

    // head (circle)
    ctx.beginPath(); ctx.arc(0, -18, 12, 0, Math.PI*2); ctx.fill();

    // neck / torso
    ctx.fillRect(-8, -8, 16, 24);

    // left arm (upper)
    ctx.save();
    ctx.translate(-8, -4);
    ctx.rotate((f.armAngle) * Math.PI / 180);
    ctx.fillRect(-4, 0, 6, 22);
    ctx.restore();

    // right arm
    ctx.save();
    ctx.translate(8, -4);
    ctx.rotate((-f.armAngle) * Math.PI / 180);
    ctx.fillRect(-2, 0, 6, 22);
    ctx.restore();

    // legs (two rectangles with offset)
    ctx.fillRect(-10, 16 + f.legOffset/2, 8, 28);
    ctx.fillRect(2, 16 - f.legOffset/2, 8, 28);

    ctx.restore();
  }
}

/* ---------- Other objects ---------- */
class Platform { constructor(x,y,w,type='static',vx=0,range=0){ this.x=x; this.y=y; this.w=w; this.h=20; this.type=type; this.vx=vx; this.range=range; this.origX=x; } update(dt){ if(this.type==='moving'){ this.x += this.vx * (dt/16); if(this.x < this.origX-this.range || this.x > this.origX+this.range) this.vx *= -1; } } draw(){ ctx.fillStyle = this.type==='moving'? '#111827' : '#374151'; ctx.fillRect(this.x - camX, this.y, this.w, this.h); ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.strokeRect(this.x - camX, this.y, this.w, this.h); } }
class Spike { constructor(x,y,w=28){ this.x=x; this.y=y; this.w=w; this.h=w; } draw(){ ctx.fillStyle='#b91c1c'; ctx.beginPath(); ctx.moveTo(this.x - camX, this.y + this.h); ctx.lineTo(this.x - camX + this.w/2, this.y); ctx.lineTo(this.x - camX + this.w, this.y + this.h); ctx.fill(); ctx.strokeStyle='#7b0000'; ctx.stroke(); } }
class PopSpike { constructor(x,y){ this.x=x; this.baseY=y+40; this.y=this.baseY; this.w=28; this.h=28; this.triggerAt=x-140; this.active=false; this.timer=0; } activate(){ this.active=true; this.timer=18; } update(dt){ if(this.active && this.timer>0){ this.y -= 6; this.timer--; } else if(this.active && this.timer===0){ if(this.y <= this.baseY - 40) this.timer = -36; } else if(this.active && this.timer < 0){ this.y += 6; this.timer++; if(this.y >= this.baseY){ this.y = this.baseY; this.active=false; this.timer=0; } } } draw(){ ctx.fillStyle='#b91c1c'; ctx.beginPath(); ctx.moveTo(this.x - camX, this.y + this.h); ctx.lineTo(this.x - camX + this.w/2, this.y); ctx.lineTo(this.x - camX + this.w, this.y + this.h); ctx.fill(); ctx.strokeStyle='#7b0000'; ctx.stroke(); } }
class FakeFloor { constructor(x,y,w,delay=18){ this.x=x; this.y=y; this.w=w; this.h=16; this.delay=delay; this.stepStarted=false; this.timer=0; this.broken=false; } draw(){ ctx.fillStyle = this.broken ? '#4b5563' : '#8b5e34'; ctx.fillRect(this.x - camX, this.y, this.w, this.h); } }
class Coin { constructor(x,y,size=16){ this.x=x; this.y=y; this.size=size; this.collected=false; } draw(){ if(this.collected) return; ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(this.x - camX + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='#b8860b'; ctx.stroke(); } }
class Checkpoint { constructor(x,y){ this.x=x; this.y=y; this.activated=false; } draw(){ ctx.fillStyle = this.activated ? '#10b981' : '#ffd54f'; ctx.beginPath(); ctx.roundRect(this.x - camX - 6, this.y - 50, 12, 40, 4); ctx.fill(); ctx.fillStyle = this.activated ? '#064e3b' : '#6d4c41'; ctx.fillRect(this.x - camX - 10, this.y - 12, 32, 8); } }

/* ----------------- Level generation ----------------- */
let level = { platforms:[], spikes:[], popSpikes:[], fakeFloors:[], coins:[], checkpoints:[], mapWidth: SEGMENT_W * START_SEGMENTS, finishX:0 };
function rand(min,max){ return Math.random()*(max-min)+min; } function rint(a,b){ return Math.floor(rand(a,b+1)); }

function buildLevelFor(number){
  level.platforms=[]; level.spikes=[]; level.popSpikes=[]; level.fakeFloors=[]; level.coins=[]; level.checkpoints=[];
  const difficulty = Math.min(1, 0.12 + (number-1)*0.06);
  const segments = START_SEGMENTS + Math.floor(number*0.6);
  level.mapWidth = segments * SEGMENT_W;

  level.platforms.push(new Platform(0,420, level.mapWidth + 400));

  let x = 220;
  while(x < level.mapWidth - 240){
    const gap = rint(100 + Math.floor(difficulty*120), 220 + Math.floor(difficulty*160));
    const pW = rint(120, 380);
    const pY = rint(260, 400 - Math.floor(difficulty*60));
    const px = x + gap;
    level.platforms.push(new Platform(px, pY, pW));
    if(Math.random() < 0.12 + difficulty*0.25){
      const mv = new Platform(px + rint(20,80), pY - 40, rint(80,140), 'moving', (Math.random()<0.5?1:-1)*(1.2 + difficulty*1.6), rint(40, 140));
      level.platforms.push(mv);
    }
    if(Math.random() < 0.3 + difficulty*0.5){
      const sx = px + rint(10, Math.max(20, pW-30));
      level.spikes.push(new Spike(sx, pY - 28));
    }
    if(Math.random() < 0.18 + difficulty*0.45){
      const psx = px + rint(-40, Math.max(40, pW+40));
      level.popSpikes.push(new PopSpike(psx, pY));
    }
    if(Math.random() < 0.16 + difficulty*0.35){
      const fx = px + rint(40, Math.max(40, pW-40));
      level.fakeFloors.push(new FakeFloor(fx, pY - 16, rint(60,140)));
    }
    // coins
    if(Math.random() < 0.5){
      const coinCount = rint(1,3);
      for(let i=0;i<coinCount;i++){
        const cx = px + rint(20, Math.max(20, pW-20));
        const cy = pY - rint(40, 80);
        level.coins.push(new Coin(cx, cy, 14));
      }
    }
    // checkpoint
    if(Math.random() < 0.18 + difficulty*0.03){
      const cpx = px + Math.min(120, Math.max(60, Math.floor(pW/2)));
      level.checkpoints.push(new Checkpoint(cpx, pY));
    }

    x += gap + pW + rint(80,200);
    if(x > level.mapWidth - 240) break;
  }

  if(level.checkpoints.length === 0){
    const mid = Math.floor(level.mapWidth/2);
    level.checkpoints.push(new Checkpoint(mid, 360));
  }
  level.finishX = level.mapWidth - 160;
}

/* ----------------- State ----------------- */
let player = new Player();
let camX = 0;
let levelNumber = 1;
let score = 0;
let coinsCollected = 0;
let paused = false;
let menuVisible = true;

/* ----------------- Control functions ----------------- */
function begin(){ menuVisible=false; startPanel.style.display='none'; howPanel.style.display='none'; pausePanel.style.display='none'; buildLevelFor(levelNumber); player.checkpointX = 120; player.checkpointY = 360; player.reset(); camX=0; score=0; coinsCollected=0; coinsEl.innerText = coinsCollected; lastTime = performance.now(); requestAnimationFrame(loop); }
function resetAll(full=false){ levelNumber=1; score=0; coinsCollected=0; player.checkpointX=120; player.checkpointY=360; player.reset(); buildLevelFor(levelNumber); camX=0; levelEl.innerText=levelNumber; scoreEl.innerText=score; coinsEl.innerText=coinsCollected; localStorage.setItem('lv_high', HIGH_SCORE); menuVisible=false; startPanel.style.display='none'; pausePanel.style.display='none'; }
function togglePause(){ paused = !paused; if(paused){ pausePanel.style.display='block'; } else { pausePanel.style.display='none'; lastTime = performance.now(); requestAnimationFrame(loop); } }
function resumeGame(){ paused=false; pausePanel.style.display='none'; lastTime = performance.now(); requestAnimationFrame(loop); }

/* ----------------- Advance level ----------------- */
function advanceLevel(){
  levelNumber++;
  levelEl.innerText = levelNumber;
  score += Math.floor(level.mapWidth/10);
  scoreEl.innerText = score;
  if(score > HIGH_SCORE){ HIGH_SCORE = score; localStorage.setItem('lv_high', HIGH_SCORE); bestEl.innerText = HIGH_SCORE; }
  buildLevelFor(levelNumber);
  player.checkpointX = 120; player.checkpointY = 360;
  player.reset(); camX = 0;
}

/* ----------------- Loop ----------------- */
let lastTime = performance.now();
function loop(now){
  if(paused || menuVisible){ lastTime = performance.now(); return; }
  const dt = Math.min(40, now - lastTime);
  lastTime = now;

  for(let p of level.platforms) if(p.type === 'moving') p.update(dt);
  for(let ps of level.popSpikes){ if(!ps.active && player.x > ps.triggerAt) ps.activate(); if(ps.active) ps.update(dt); }
  for(let f of level.fakeFloors){
    if(!f.broken && player.x + player.w > f.x && player.x < f.x + f.w && player.y + player.h > f.y && player.y < f.y + f.h){
      if(!f.stepStarted){ f.stepStarted = true; f.timer = f.delay; }
    }
    if(f.stepStarted && f.timer > 0) f.timer--;
    if(f.stepStarted && f.timer === 0 && !f.broken) f.broken = true;
    if(f.broken) f.y += 6 * (dt/16);
  }

  player.update(dt);

  camX = player.x - CAMERA_LEFT_PADDING; if(camX < 0) camX = 0;

  score = Math.max(score, Math.floor(player.x + (levelNumber-1)*500));
  scoreEl.innerText = score;

  // update checkpoint info (player.checkpointX updated when cp activated)
  for(let cp of level.checkpoints){
    if(cp.activated && cp.x > player.checkpointX){
      player.checkpointX = cp.x - 20;
      player.checkpointY = cp.y - player.h;
    }
  }

  if(player.x > level.mapWidth - 120){ advanceLevel(); }

  drawScene();

  requestAnimationFrame(loop);
}

/* ----------------- Drawing ----------------- */
function drawScene(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // simple sky bg
  const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#87CEEB'); g.addColorStop(1,'#cfe9ff'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

  // ground
  ctx.fillStyle = '#2d3748'; ctx.fillRect(-camX, 460, canvas.width + camX, canvas.height - 460);

  // platforms
  for(let p of level.platforms) p.draw();
  // fake floors
  for(let f of level.fakeFloors) f.draw();
  // spikes
  for(let s of level.spikes) s.draw();
  // pop spikes
  for(let ps of level.popSpikes) ps.draw();
  // coins
  for(let c of level.coins) c.draw();
  // checkpoints
  for(let cp of level.checkpoints) cp.draw();

  // finish flag
  ctx.fillStyle = '#ffd54f'; ctx.fillRect(level.finishX - camX, 300, 12, 140);
  ctx.fillStyle = '#6d4c41'; ctx.fillRect(level.finishX - camX - 8, 420, 36, 20);

  // player silhouette
  player.draw();

  // hint box
  ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(canvas.width - 220, 8, 210, 36);
  ctx.fillStyle = '#fff'; ctx.font = '14px Inter, Arial'; ctx.fillText('Finish →', canvas.width - 180, 30);
}

/* ----------------- Init ----------------- */
buildLevelFor(levelNumber);
levelEl.innerText = levelNumber;
scoreEl.innerText = score;
coinsEl.innerText = coinsCollected || 0;
updateMute = ()=>{ muteBtn.innerText = SOUND_ON ? 'Mute' : 'Unmute'; };
updateMute();

startPanel.style.display = 'block';
pausePanel.style.display = 'none';
howPanel.style.display = 'none';
menuVisible = true;

</script>
</body>
</html>
